
@article{woodcock_formal_2009,
	title = {Formal methods: {Practice} and experience},
	volume = {41},
	issn = {0360-0300},
	shorttitle = {Formal methods},
	url = {https://doi.org/10.1145/1592434.1592436},
	doi = {10.1145/1592434.1592436},
	abstract = {Formal methods use mathematical models for analysis and verification at any part of the program life-cycle. We describe the state of the art in the industrial use of formal methods, concentrating on their increasing use at the earlier stages of specification and design. We do this by reporting on a new survey of industrial use, comparing the situation in 2009 with the most significant surveys carried out over the last 20 years. We describe some of the highlights of our survey by presenting a series of industrial projects, and we draw some observations from these surveys and records of experience. Based on this, we discuss the issues surrounding the industrial adoption of formal methods. Finally, we look to the future and describe the development of a Verified Software Repository, part of the worldwide Verified Software Initiative. We introduce the initial projects being used to populate the repository, and describe the challenges they address.},
	number = {4},
	urldate = {2024-12-07},
	journal = {ACM Comput. Surv.},
	author = {Woodcock, Jim and Larsen, Peter Gorm and Bicarregui, Juan and Fitzgerald, John},
	month = oct,
	year = {2009},
	pages = {19:1--19:36},
	file = {Submitted Version:/home/georgefkd/Zotero/storage/4ANI6N94/Woodcock et al. - 2009 - Formal methods Practice and experience.pdf:application/pdf},
}

@article{dept_of_banking_technology_pondicherry_university_puducherry_india_formal_2018,
	title = {A {Formal} {Model} for {Legacy} {System} {Understanding}},
	volume = {10},
	issn = {2074904X, 20749058},
	url = {http://www.mecs-press.org/ijisa/ijisa-v10-n10/v10n10-4.html},
	doi = {10.5815/ijisa.2018.10.04},
	abstract = {Migration of legacy system is not a single step activity but a process that comprises of several phases of which Legacy System Understanding (LSU) is the first step. The intent of this work is to carry out a detailed study on the Legacy System Understanding in terms of Techniques and Tools used and to identify the potential gaps in them. The understanding of the legacy system has to be at the perspective of system level rather than the code level which has a narrow perspective, because the migration at code level may have a cascading impact to different aspects of the Legacy System. These findings have enabled us to formulate a process for building up an artefact repository and artefact dependency repository. These repositories along with the legacy system have aided us in understanding the legacy system in a comprehensive manner in terms of migrating artefacts in the context of migration of legacy systems. A formal mathematical model for representing the status of LSU and application of the same on a case study has been presented.},
	language = {en},
	number = {10},
	urldate = {2024-12-07},
	journal = {International Journal of Intelligent Systems and Applications},
	author = {{Dept. of Banking Technology, Pondicherry University, Puducherry, India} and Ganesan, A.Sivagnana and Chithralekha, T. and Rajapandian, M.},
	month = oct,
	year = {2018},
	pages = {27--41},
	file = {Dept. of Banking Technology, Pondicherry University, Puducherry, India et al. - 2018 - A Formal Model for Legacy System Understanding.pdf:/home/georgefkd/Zotero/storage/XNMSJNWM/Dept. of Banking Technology, Pondicherry University, Puducherry, India et al. - 2018 - A Formal Model for Legacy System Understanding.pdf:application/pdf},
}

@article{ward_formal_1995,
	title = {Formal methods for legacy systems},
	volume = {7},
	copyright = {Copyright © 1995 John Wiley \& Sons, Ltd},
	issn = {1096-908X},
	url = {https://onlinelibrary.wiley.com/doi/abs/10.1002/smr.4360070305},
	doi = {10.1002/smr.4360070305},
	abstract = {A method is described for obtaining useful information from legacy code. The approach uses formal proven program transformations, which preserve or refine the semantics of a construct while changing its form. The applicability of a transformation in a particular syntactic context is checked before application. By using an appropriate sequence of transformations, the extracted representation is guaranteed to be equivalent to the code. In this paper, we focus on the results of using this approach in the reverse-engineering of medium-scale, industrial software, written mostly in languages such as assembler and JOVIAL. Results from both benchmark algorithms and heavily modified, geriatric software are summarized. It is concluded that the approach is viable, for self-contained code, and that useful design information may be extracted from legacy systems at economic cost. We conclude that formal methods have an important practical role in the reverse-engineering process.},
	language = {en},
	number = {3},
	urldate = {2024-12-07},
	journal = {Journal of Software Maintenance: Research and Practice},
	author = {Ward, M. P. and Bennett, K. H.},
	year = {1995},
	note = {\_eprint: https://onlinelibrary.wiley.com/doi/pdf/10.1002/smr.4360070305},
	keywords = {formal transformations, legacy systems, refinement, restructuring, reverse engineering},
	pages = {203--219},
	file = {Snapshot:/home/georgefkd/Zotero/storage/KPX942TZ/smr.html:text/html;Submitted Version:/home/georgefkd/Zotero/storage/MPTGPMNR/Ward and Bennett - 1995 - Formal methods for legacy systems.pdf:application/pdf},
}

@article{ter_beek_formal_2024,
	title = {Formal {Methods} in {Industry}},
	issn = {0934-5043, 1433-299X},
	url = {https://dl.acm.org/doi/10.1145/3689374},
	doi = {10.1145/3689374},
	abstract = {Formal methods encompass a wide choice of techniques and tools for the specification, development, analysis, and verification of software and hardware systems. Formal methods are widely applied in industry, in activities ranging from the elicitation of requirements and the early design phases all the way to the deployment, configuration, and runtime monitoring of actual systems. Formal methods allow one to precisely specify the environment in which a system operates, the requirements and properties that the system should satisfy, the models of the system used during the various design steps, and the code embedded in the final implementation, as well as to express conformance relations between these specifications. We present a broad scope of successful applications of formal methods in industry, not limited to the well-known success stories from the safety-critical domain, like railways and other transportation systems, but also covering other areas such as lithography manufacturing and cloud security in e-commerce, to name but a few. We also report testimonies from a number of representatives from industry who, either directly or indirectly, use or have used formal methods in their industrial project endeavours. These persons are spread geographically, including Europe, Asia, North and South America, and the involved projects witness the large coverage of applications of formal methods, not limited to the safety-critical domain. We thus make a case for the importance of formal methods, and in particular of the capacity to abstract and mathematical reasoning that are taught as part of any formal methods course. These are fundamental Computer Science skills that graduates should profit from when working as computer scientists in industry, as confirmed by industry representatives.},
	language = {en},
	urldate = {2024-12-04},
	journal = {Formal Aspects of Computing},
	author = {Ter Beek, Maurice H. and Chapman, Rod and Cleaveland, Rance and Garavel, Hubert and Gu, Rong and Ter Horst, Ivo and Keiren, Jeroen J. A. and Lecomte, Thierry and Leuschel, Michael and Rozier, Kristin Yvonne and Sampaio, Augusto and Seceleanu, Cristina and Thomas, Martyn and Willemse, Tim A. C. and Zhang, Lijun},
	month = aug,
	year = {2024},
	pages = {3689374},
	file = {Available Version (via Google Scholar):/home/georgefkd/Zotero/storage/2KW7BXIJ/Ter Beek et al. - 2024 - Formal Methods in Industry.pdf:application/pdf},
}

@article{lundy_making_2024,
	title = {Making formal methods work: what is being done and what can be done},
	volume = {9},
	shorttitle = {Making formal methods work},
	url = {https://www.witpress.com/elibrary/wit-transactions-on-information-and-communication-technologies/9/11910},
	urldate = {2024-12-04},
	journal = {WIT Transactions on Information and Communication Technologies},
	author = {Lundy, P. and Bustard, D. W.},
	year = {2024},
	note = {Publisher: WIT Press},
}

@phdthesis{dellabani_formal_2018,
	type = {phdthesis},
	title = {Formal methods for distributed real-time systems},
	url = {https://theses.hal.science/tel-02146390},
	abstract = {Aujourd'hui, les systèmes temps réel sont omniprésents dans plusieurs domaines.Une telle expansion donne lieu à un besoin croissant en terme de performance (ressources,disponibilité, parallélisme, etc.) et a initié par la même occasion une transition del'utilisation de plateformes matérielles à processeur unique, à de grands ensemblesde nœuds de calcul inter-connectés et distribués. Cette tendance a donné la naissanceà une nouvelle famille de systèmes connue sous le nom de emph\{Networked Embedded Systems\},qui sont intrinsèquement distribués.Une telle évolution provient de la complexité croissante des logiciels temps réelembarqués sur de telles plateformes (par exemple les système de contrôle en avioniqueet dans domaines de l'automobile), ainsi que la nécessité d'intégrer des systèmes autrefoisisolés afin d'accomplir les fonctionnalités requises, améliorant ainsi les performanceset réduisant les coûts.Sans surprise, la conception, l'implémentation et la vérification de ces systèmes sontdes tâches très difficiles car ils sont sujets à différents types de facteurs, tels que lesdélais de communication, la fréquence du CPU ou même les imprécisions matérielles,ce qui augmente considérablement la complexité lorsqu'il s'agit de coordonner les activités parallèles.Dans cette thèse, nous proposons une démarche rigoureuse destinée à la construction d'applicationsdistribuées temps réel.Pour ce faire, nous étudions des modèles basés sur les automates temporisés, dont la sémantiqueest formellement définie, afin d'étudier le comportement d'un système donné avec des contraintes de tempsimposées lorsqu'il est déployé dans un environnement distribué. En particulier, nous étudionsemph\{(i)\} l'impact des délais de communication en introduisant une latence minimale entreles exécutions d'actions et la date à laquelle elles ont été décidées,et emph\{(ii)\} l'effet des imperfections matérielles, plus précisément les imprécisionsd'horloges, sur l'exécution des systèmes.Le paradigme des automates temporisés reste néanmoins destiné à décrire une abstractiondu comportement d'une application donnée.Par conséquent, nous utilisons une représentation intermédiaire del'application initiale, qui en plus d'avoir un comportement say\{équivalent\}, exprimeexplicitement les mécanismes mis en œuvre durant l'implémentation, et donc réduit ainsil'écart entre la modélisation et l'implémentation réelle.De plus, nous contribuons à la construction de tels systèmes en emph\{(iii)\}proposant une optimisation basée sur la emph\{connaissance\}, qui a pour but d'éliminer lestemps de calcul inutiles et de réduire les échanges de messages pendant l'exécution. Nous comparons le comportement de chaque modèle proposé au modèle initial et étudionsles relations entre les deux. Ensuite, nous identifions et caractérisons formellement lesproblèmes potentiels résultants de ces contraintes supplémentaires. Aussi, nous proposonsdes stratégies d'exécution qui permettent de préserver certaines propriétés souhaitéeset d'obtenir des scénarios d'exécution say\{similaires\}, et fidèles aux spécificationsde départs.},
	language = {en},
	urldate = {2024-12-04},
	school = {Université Grenoble Alpes},
	author = {Dellabani, Mahieddine},
	month = oct,
	year = {2018},
	file = {Full Text PDF:/home/georgefkd/Zotero/storage/J5H9VMJK/Dellabani - 2018 - Formal methods for distributed real-time systems.pdf:application/pdf},
}

@inproceedings{eikermann_reuse_2019,
	address = {Cham},
	title = {Reuse and {Customization} for {Code} {Generators}: {Synergy} by {Transformations} and {Templates}},
	isbn = {978-3-030-11030-7},
	shorttitle = {Reuse and {Customization} for {Code} {Generators}},
	doi = {10.1007/978-3-030-11030-7_3},
	abstract = {Engineering languages for model-driven development (MDD) highly rely on code generators that systematically and efficiently generate source code from abstract models. Although code generation is an essential technique, there is still a lot of ad hoc mechanisms in use that prevent an efficient and reliable use and especially reuse of code generators.},
	language = {en},
	booktitle = {Model-{Driven} {Engineering} and {Software} {Development}},
	publisher = {Springer International Publishing},
	author = {Eikermann, Robert and Hölldobler, Katrin and Roth, Alexander and Rumpe, Bernhard},
	editor = {Hammoudi, Slimane and Pires, Luís Ferreira and Selic, Bran},
	year = {2019},
	keywords = {Code generation, Code generator development, Model-to-model transformation},
	pages = {34--55},
	file = {Full Text PDF:/home/georgefkd/Zotero/storage/WNM7ACV3/Eikermann et al. - 2019 - Reuse and Customization for Code Generators Syner.pdf:application/pdf},
}

@article{norman_quantitative_2014,
	title = {Quantitative verification: {Formal} guarantees for timeliness, reliability and performance},
	shorttitle = {Quantitative verification},
	url = {https://eprints.gla.ac.uk/96376/},
	urldate = {2024-12-16},
	author = {Norman, Gethin and Parker, David},
	year = {2014},
	note = {Publisher: London Mathematical Society and Smith Institute},
	file = {Available Version (via Google Scholar):/home/georgefkd/Zotero/storage/QPUQCWYI/Norman and Parker - 2014 - Quantitative verification Formal guarantees for t.pdf:application/pdf},
}

@article{haddou-oumouloud_toward_2024,
	title = {Toward {Secure} and {Reliable} {IoT} {Systems}: {A} {Comprehensive} {Review} of {Formal} {Methods} {Applications}},
	volume = {12},
	issn = {2169-3536},
	shorttitle = {Toward {Secure} and {Reliable} {IoT} {Systems}},
	url = {https://ieeexplore.ieee.org/abstract/document/10756658},
	doi = {10.1109/ACCESS.2024.3501587},
	abstract = {The exponential growth of Internet of Things (IoT) applications poses substantial obstacles in guaranteeing their dependability, safety, and effectiveness. Formal methods provide precise mathematical techniques for modeling, verifying, and analyzing these systems, effectively addressing important aspects of their creation and implementation. This review provides a thorough examination of the utilization of formal methods in the field of IoT, focusing on recent research published in well- regarded academic journals and conferences. We examine different formal methodologies, such as temporal logic, automata theory, theorem proving, and formal specification languages, emphasizing their efficacy in tackling difficulties peculiar to IoT systems. The review assesses the benefits and constraints of these methodologies, contrasts various approaches, and integrates essential discoveries. Key contributions include a comprehensive overview of formal methods applications, identification of critical challenges, evaluation of the effectiveness of different techniques, and proposals for future research directions. By highlighting emerging trends and future research paths, this review underscores the significance of formal approaches in enhancing the safety and resilience of IoT systems. This review seeks to serve as a beneficial reference for researchers and practitioners looking to improve IoT applications through formal verification and analysis techniques.},
	urldate = {2024-12-16},
	journal = {IEEE Access},
	author = {Haddou-Oumouloud, Ikram and Kriouile, Abderahman and Hamida, Soufiane and Ettalbi, Ahmed},
	year = {2024},
	note = {Conference Name: IEEE Access},
	keywords = {Scalability, Reliability, Security, Formal methods, formal specification, Formal specifications, hybrid approaches, Internet of Things, Internet of Things (IoT), IoT safety and privacy, IoT system analysis, Logic, Medical services, model checking, Real-time systems, reliability in IoT, Resilience, Reviews, theorem proving, verification and validation},
	pages = {171853--171875},
	file = {Full Text PDF:/home/georgefkd/Zotero/storage/T89IAHZL/Haddou-Oumouloud et al. - 2024 - Toward Secure and Reliable IoT Systems A Comprehe.pdf:application/pdf;IEEE Xplore Abstract Record:/home/georgefkd/Zotero/storage/JTPIJPWH/10756658.html:text/html},
}

@article{dongol_formal_2024,
	title = {On {Formal} {Methods} {Thinking} in {Computer} {Science} {Education}},
	issn = {0934-5043, 1433-299X},
	url = {https://dl.acm.org/doi/10.1145/3670419},
	doi = {10.1145/3670419},
	abstract = {Formal Methods (FM) radically improve the quality of the code artefacts they help to produce. They are simple, probably accessible to first-year undergraduate students and certainly to second-year students and beyond. Nevertheless, in many cases, they are not part of a general recommendation for course curricula, i.e., they are not taught — and yet they are valuable.
            
              One reason for this is that teaching “Formal Methods” is often confused with teaching logic and theory. This paper advocates what we call
              FM thinking
              : the application of
              ideas
              from
              Formal
              Methods applied in informal, lightweight, practical and accessible ways. And we will argue here that
              FM thinking
              should be part of the recommended curriculum for every Computer Science student. For even students who train only in that “thinking” will become much better programmers. But there will be others who, exposed to those ideas, will be ideally positioned to go further into the more theoretical background: why the techniques work; how they can be automated; and how new ones can be developed. Those students would follow subsequently a specialised, more theoretical stream, including topics such as semantics, logics, verification and proof-automation techniques.},
	language = {en},
	urldate = {2024-12-16},
	journal = {Formal Aspects of Computing},
	author = {Dongol, Brijesh and Dubois, Catherine and Hallerstede, Stefan and Hehner, Eric and Morgan, Carroll and Müller, Peter and Ribeiro, Leila and Silva, Alexandra and Smith, Graeme and De Vink, Erik},
	month = jun,
	year = {2024},
	pages = {3670419},
	file = {Available Version (via Google Scholar):/home/georgefkd/Zotero/storage/SJGPMYYY/Dongol et al. - 2024 - On Formal Methods Thinking in Computer Science Edu.pdf:application/pdf},
}

@inproceedings{gerasimou_search-based_2015,
	title = {Search-based synthesis of probabilistic models for quality-of-service software engineering (t)},
	url = {https://ieeexplore.ieee.org/abstract/document/7372021/},
	urldate = {2024-12-17},
	booktitle = {2015 30th {IEEE}/{ACM} {International} {Conference} on {Automated} {Software} {Engineering} ({ASE})},
	publisher = {IEEE},
	author = {Gerasimou, Simos and Tamburrelli, Giordano and Calinescu, Radu},
	year = {2015},
	pages = {319--330},
	file = {Available Version (via Google Scholar):/home/georgefkd/Zotero/storage/3MPUZZKM/Gerasimou et al. - 2015 - Search-based synthesis of probabilistic models for quality-of-service software engineering (t).pdf:application/pdf},
}

@article{paterson_observation-enhanced_2018,
	title = {Observation-enhanced {QoS} analysis of component-based systems},
	volume = {46},
	url = {https://ieeexplore.ieee.org/abstract/document/8428471/},
	number = {5},
	urldate = {2024-12-17},
	journal = {IEEE Transactions on Software Engineering},
	author = {Paterson, Colin and Calinescu, Radu},
	year = {2018},
	note = {Publisher: IEEE},
	pages = {526--548},
	file = {Available Version (via Google Scholar):/home/georgefkd/Zotero/storage/LIGUZ6QB/Paterson and Calinescu - 2018 - Observation-enhanced QoS analysis of component-based systems.pdf:application/pdf},
}

@article{alidoost_nia_probabilistic_2020,
	title = {Probabilistic approximation of runtime quantitative verification in self-adaptive systems},
	volume = {72},
	issn = {0141-9331},
	url = {https://www.sciencedirect.com/science/article/pii/S0141933118303843},
	doi = {10.1016/j.micpro.2019.102943},
	abstract = {Cyber-physical systems (CPS) are expected to continuously monitor the physical components to autonomously calculate appropriate runtime reactions to deal with the uncertain environmental conditions. Self-adaptation, as a promising concept to fulfill a set of provable rules, majorly needs runtime quantitative verification (RQV). Taking a few probabilistic variables into account to represent the uncertainties, the system configuration will be extremely large. Thus, efficient approaches are needed to reduce the model state-space, preferably with certain bounds on the approximation error. In this paper, we propose an approximation framework to efficiently approximate the entire model of a self-adaptive system. We split up the large model into strongly-connected components (SCCs), apply the approximation algorithm separately on each SCC, and integrate the result of each part using a centralized algorithm. Due to a number of changes in probabilistic variables, it is not possible to use static models. Addressing this issue, we have deployed parametric Markov decision process. In order to apply approximation on the model, the notion of ε-approximate probabilistic bisimulation is utilized that introduces the approximation level ε. We show that our approximation framework offers a certain error bound on each level of approximation. Then, we denote that the approximation framework is appropriate to be applied in decision-making process of self-adaptive systems where the models are relatively large. The results reveal that we can achieve up to 50\% size reduction in the approximate model while maintaining the accuracy about 95\%. In addition, we discuss about the trade-off between efficiency and accuracy of our approximation framework.},
	urldate = {2024-12-18},
	journal = {Microprocessors and Microsystems},
	author = {Alidoost Nia, Mehran and Kargahi, Mehdi and Faghih, Fathiyeh},
	month = feb,
	year = {2020},
	keywords = {Approximation techniques, Cyber-physical systems, Markov decision process, Probabilistic model checking, Runtime verification, Self-adaptive systems},
	pages = {102943},
	file = {PDF:/home/georgefkd/Zotero/storage/MRCG7RYM/Alidoost Nia et al. - 2020 - Probabilistic approximation of runtime quantitative verification in self-adaptive systems.pdf:application/pdf;ScienceDirect Snapshot:/home/georgefkd/Zotero/storage/C3TDYY9T/S0141933118303843.html:text/html},
}

@article{trinh_checking_2024,
	title = {Checking {Temporal} {Constraints} of {Events} in {EBS} at {Runtime}},
	volume = {24},
	copyright = {http://creativecommons.org/licenses/by-nc-nd/4.0},
	issn = {1314-4081},
	url = {https://www.sciendo.com/article/10.2478/cait-2024-0005},
	doi = {10.2478/cait-2024-0005},
	abstract = {Abstract
            As a kind of software system, the Event-Based Systems (EBS) respond to events rather than executing a predefined sequence of instructions. Events usually occur in real time, so it is crucial that they are processed in the correct order and within temporal constraints. The objective of this work is to propose an approach to check if events of EBS at runtime preserve the specification of temporal constraints. To form the approach by logic process, we have formalized the EBS model, through which, we have proved that the complexity of the checking algorithms is only polynomial. The approach has been implemented as a tool (VER) to check EBS at runtime automatically. The results of the proposed method are illustrated by checking a real-world Event Driven Architecture (EDA) application, an Intelligent transportation system.},
	language = {en},
	number = {1},
	urldate = {2024-12-18},
	journal = {Cybernetics and Information Technologies},
	author = {Trinh, Thanh-Binh and Nguyen, Hanh-Phuc and Nguyen, Dinh-Hai and To, Van-Khanh and Truong, Ninh-Thuan},
	month = mar,
	year = {2024},
	pages = {82--97},
	file = {Available Version (via Google Scholar):/home/georgefkd/Zotero/storage/3L57YYH7/Trinh et al. - 2024 - Checking Temporal Constraints of Events in EBS at Runtime.pdf:application/pdf},
}

@article{yang_symbolic_1997,
	title = {Symbolic model checking for event-driven real-time systems},
	volume = {19},
	issn = {0164-0925, 1558-4593},
	url = {https://dl.acm.org/doi/10.1145/244795.244803},
	doi = {10.1145/244795.244803},
	language = {en},
	number = {2},
	urldate = {2024-12-18},
	journal = {ACM Transactions on Programming Languages and Systems},
	author = {Yang, Jin and Mok, Aloysius K. and Wang, Farn},
	month = mar,
	year = {1997},
	pages = {386--412},
	file = {Available Version (via Google Scholar):/home/georgefkd/Zotero/storage/XS6ERLNY/Yang et al. - 1997 - Symbolic model checking for event-driven real-time systems.pdf:application/pdf},
}

@inproceedings{tran_espin_2023,
	address = {Cham},
	title = {{ESpin}: {Analyzing} {Event}-{Driven} {Systems} in {Model} {Checking}},
	isbn = {978-3-031-36886-8},
	shorttitle = {{ESpin}},
	doi = {10.1007/978-3-031-36886-8_31},
	abstract = {Multiple occurrences of the events make the behaviors of an event-driven system usually less logical and explicit. Thus, an event-driven system is hard to be analyzed and found errors. In this paper, we introduce an approach to analyze event-driven systems following the properties related to the occurrence of the events. Our method is based on the exploration of the states of the system using model checking techniques. To that end, we introduced a domain-specific language (DSL) to easily describe the behaviors of the system. The specification of the system in the DSL is then translated into the model of the system to explore the states of the system. The property to be checked is used to realize the model checking algorithm that is used to label the graph realized from the state space. The experiment results show that we can facilitate the specification of the system and analyze the behaviors of the system correctly.},
	language = {en},
	booktitle = {The 12th {Conference} on {Information} {Technology} and {Its} {Applications}},
	publisher = {Springer Nature Switzerland},
	author = {Tran, Nhat-Hoa},
	editor = {Nguyen, Ngoc Thanh and Le-Minh, Hoa and Huynh, Cong-Phap and Nguyen, Quang-Vu},
	year = {2023},
	keywords = {CTL/RTCTL properties, Domain-specific language, Event-driven systems, Model checking techniques},
	pages = {368--379},
	file = {Full Text PDF:/home/georgefkd/Zotero/storage/9N87L8Z9/Tran - 2023 - ESpin Analyzing Event-Driven Systems in Model Checking.pdf:application/pdf},
}

@inproceedings{ericsson_seamless_2007,
	address = {Toronto Ontario Canada},
	title = {Seamless formal verification of complex event processing applications},
	isbn = {978-1-59593-665-3},
	url = {https://dl.acm.org/doi/10.1145/1266894.1266903},
	doi = {10.1145/1266894.1266903},
	language = {en},
	urldate = {2024-12-18},
	booktitle = {Proceedings of the 2007 inaugural international conference on {Distributed} event-based systems},
	publisher = {ACM},
	author = {Ericsson, AnnMarie and Pettersson, Paul and Berndtsson, Mikael and Seiriö, Marco},
	month = jun,
	year = {2007},
	pages = {50--61},
	file = {Available Version (via Google Scholar):/home/georgefkd/Zotero/storage/KL9U6SRV/Ericsson et al. - 2007 - Seamless formal verification of complex event processing applications.pdf:application/pdf},
}

@article{ma_consistency_2017,
	title = {On the consistency of event processing: {A} semantic approach},
	volume = {137},
	issn = {0950-7051},
	shorttitle = {On the consistency of event processing},
	url = {https://www.sciencedirect.com/science/article/pii/S0950705117303775},
	doi = {10.1016/j.knosys.2017.08.021},
	abstract = {Event processing is one of the cornerstone technologies in bridging physical world and cyber system together. Although event-based processing system has been widely used in various applications, however, consistency of event processing is still an open issue need further exploration. The inconsistency problem produces inaccurate detection result and corrupts the system correctness. In this paper, we propose a semantic approach for event modeling and detection model transformation with a semantic calculus system. Particularly, we first propose a complex event semantic model, OntoEvent, and define several key operators and properties to describe the logic, temporal and attribute relations in complex events. Second, we propose the concept of event constraint and elaborate the occurrence, temporal, and attribute functions to formalize the semantic implications in OntoEvent model. On that basis, we present the extraction rules and establish a calculus mechanism for constraints based on axioms. With these works, an automata-based detection model, named OntoCEP (Ontology-based Complex Event Detection), and a pipelined procedure for the assembly from constraints to OntoCEP model is proposed. The procedure is composed of several sequential phases and the consistency in each assembly phase is proved. Therefore, we establish a semantic-consistent mapping mechanism from event to detection model in the form of constraints. Experiments and evaluations prove that our approach ensure the consistency with event and detection models. Besides, our detection model consumes less computational resources and outperforms other selected benchmarked models in terms of computational efficiency and processing capability.},
	urldate = {2024-12-18},
	journal = {Knowledge-Based Systems},
	author = {Ma, Meng and Wang, Ping},
	month = dec,
	year = {2017},
	keywords = {Ontology, Consistency, Data stream, Event processing, Internet of things, Semantic},
	pages = {29--41},
	file = {PDF:/home/georgefkd/Zotero/storage/KB4I74MH/Ma and Wang - 2017 - On the consistency of event processing A semantic approach.pdf:application/pdf;ScienceDirect Snapshot:/home/georgefkd/Zotero/storage/4AKVUA3Z/S0950705117303775.html:text/html},
}

@incollection{bartocci_runtime_2018,
	address = {Cham},
	title = {Runtime {Verification} for {Decentralised} and {Distributed} {Systems}},
	volume = {10457},
	isbn = {978-3-319-75631-8 978-3-319-75632-5},
	url = {http://link.springer.com/10.1007/978-3-319-75632-5_6},
	urldate = {2024-12-18},
	booktitle = {Lectures on {Runtime} {Verification}},
	publisher = {Springer International Publishing},
	author = {Francalanza, Adrian and Pérez, Jorge A. and Sánchez, César},
	editor = {Bartocci, Ezio and Falcone, Yliès},
	year = {2018},
	doi = {10.1007/978-3-319-75632-5_6},
	note = {Series Title: Lecture Notes in Computer Science},
	pages = {176--210},
	file = {Available Version (via Google Scholar):/home/georgefkd/Zotero/storage/PPG3YI6A/Francalanza et al. - 2018 - Runtime Verification for Decentralised and Distributed Systems.pdf:application/pdf},
}

@incollection{colombo_online_2018,
	address = {Cham},
	title = {Online and {Offline} {Stream} {Runtime} {Verification} of {Synchronous} {Systems}},
	volume = {11237},
	isbn = {978-3-030-03768-0 978-3-030-03769-7},
	url = {http://link.springer.com/10.1007/978-3-030-03769-7_9},
	language = {en},
	urldate = {2024-12-18},
	booktitle = {Runtime {Verification}},
	publisher = {Springer International Publishing},
	author = {Sánchez, César},
	editor = {Colombo, Christian and Leucker, Martin},
	year = {2018},
	doi = {10.1007/978-3-030-03769-7_9},
	note = {Series Title: Lecture Notes in Computer Science},
	pages = {138--163},
	file = {Available Version (via Google Scholar):/home/georgefkd/Zotero/storage/X58LX2N3/Sánchez - 2018 - Online and Offline Stream Runtime Verification of Synchronous Systems.pdf:application/pdf},
}

@book{ganguly_runtime_2023,
	title = {Runtime {Verification} of {Distributed} {Systems}},
	url = {https://search.proquest.com/openview/c612ce72ce6026a8bf96fe22170c46d2/1?pq-origsite=gscholar&cbl=18750&diss=y},
	urldate = {2024-12-18},
	publisher = {Michigan State University},
	author = {Ganguly, Ritam},
	year = {2023},
}

@article{watterson_runtime_2007,
	title = {Runtime verification and monitoring of embedded systems},
	volume = {1},
	url = {https://digital-library.theiet.org/content/journals/10.1049/iet-sen_20060076},
	number = {5},
	urldate = {2024-12-18},
	journal = {IET software},
	author = {Watterson, Conal and Heffernan, Donal},
	year = {2007},
	note = {Publisher: IET},
	pages = {172--179},
	file = {Available Version (via Google Scholar):/home/georgefkd/Zotero/storage/YS3Y4SUB/Watterson and Heffernan - 2007 - Runtime verification and monitoring of embedded systems.pdf:application/pdf},
}

@article{sanchez_survey_2019,
	title = {A survey of challenges for runtime verification from advanced application domains (beyond software)},
	volume = {54},
	issn = {0925-9856, 1572-8102},
	url = {http://link.springer.com/10.1007/s10703-019-00337-w},
	doi = {10.1007/s10703-019-00337-w},
	abstract = {Abstract
            Runtime verification is an area of formal methods that studies the dynamic analysis of execution traces against formal specifications. Typically, the two main activities in runtime verification efforts are the process of creating monitors from specifications, and the algorithms for the evaluation of traces against the generated monitors. Other activities involve the instrumentation of the system to generate the trace and the communication between the system under analysis and the monitor. Most of the applications in runtime verification have been focused on the dynamic analysis of software, even though there are many more potential applications to other computational devices and target systems. In this paper we present a collection of challenges for runtime verification extracted from concrete application domains, focusing on the difficulties that must be overcome to tackle these specific challenges. The computational models that characterize these domains require to devise new techniques beyond the current state of the art in runtime verification.},
	language = {en},
	number = {3},
	urldate = {2024-12-18},
	journal = {Formal Methods in System Design},
	author = {Sánchez, César and Schneider, Gerardo and Ahrendt, Wolfgang and Bartocci, Ezio and Bianculli, Domenico and Colombo, Christian and Falcone, Yliès and Francalanza, Adrian and Krstić, Srđan and Lourenço, Joa̋o M. and Nickovic, Dejan and Pace, Gordon J. and Rufino, Jose and Signoles, Julien and Traytel, Dmitriy and Weiss, Alexander},
	month = nov,
	year = {2019},
	pages = {279--335},
	file = {Available Version (via Google Scholar):/home/georgefkd/Zotero/storage/XAATMW64/Sánchez et al. - 2019 - A survey of challenges for runtime verification from advanced application domains (beyond software).pdf:application/pdf},
}

@article{yu_adaptively_2023,
	title = {Adaptively parallel runtime verification based on distributed network for temporal properties},
	volume = {117},
	url = {https://www.sciencedirect.com/science/article/pii/S0167819123000406},
	urldate = {2024-12-18},
	journal = {Parallel Computing},
	author = {Yu, Bin and Lu, Xu and Tian, Cong and Wang, Meng and Chen, Chu and Lei, Ming and Duan, Zhenhua},
	year = {2023},
	note = {Publisher: Elsevier},
	pages = {103034},
}

@article{ganguly_runtime_2024,
	title = {Runtime verification of partially-synchronous distributed system},
	issn = {0925-9856, 1572-8102},
	url = {https://link.springer.com/10.1007/s10703-024-00450-5},
	doi = {10.1007/s10703-024-00450-5},
	language = {en},
	urldate = {2024-12-18},
	journal = {Formal Methods in System Design},
	author = {Ganguly, Ritam and Momtaz, Anik and Bonakdarpour, Borzoo},
	month = jun,
	year = {2024},
	file = {Available Version (via Google Scholar):/home/georgefkd/Zotero/storage/8VT7JZBC/Ganguly et al. - 2024 - Runtime verification of partially-synchronous distributed system.pdf:application/pdf},
}

@misc{ouyang_multi-grained_2024,
	title = {Multi-{Grained} {Specifications} for {Distributed} {System} {Model} {Checking} and {Verification}},
	url = {http://arxiv.org/abs/2409.14301},
	doi = {10.48550/arXiv.2409.14301},
	abstract = {This paper presents our experience specifying and verifying the correctness of ZooKeeper, a complex and evolving distributed coordination system. We use TLA+ to model fine-grained behaviors of ZooKeeper and use the TLC model checker to verify its correctness properties; we also check conformance between the model and code. The fundamental challenge is to balance the granularity of specifications and the scalability of model checking -- fine-grained specifications lead to state-space explosion, while coarse-grained specifications introduce model-code gaps. To address this challenge, we write specifications with different granularities for composable modules, and compose them into mixed-grained specifications based on specific scenarios. For example, to verify code changes, we compose fine-grained specifications of changed modules and coarse-grained specifications that abstract away details of unchanged code with preserved interactions. We show that writing multi-grained specifications is a viable practice and can cope with model-code gaps without untenable state space, especially for evolving software where changes are typically local and incremental. We detected six severe bugs that violate five types of invariants and verified their code fixes; the fixes have been merged to ZooKeeper. We also improve the protocol design to make it easy to implement correctly.},
	urldate = {2024-12-18},
	publisher = {arXiv},
	author = {Ouyang, Lingzhi and Sun, Xudong and Tang, Ruize and Huang, Yu and Jivrajani, Madhav and Ma, Xiaoxing and Xu, Tianyin},
	month = sep,
	year = {2024},
	note = {arXiv:2409.14301 [cs]},
	keywords = {Computer Science - Distributed, Parallel, and Cluster Computing, Computer Science - Software Engineering},
	file = {Preprint PDF:/home/georgefkd/Zotero/storage/9CWUDAVS/Ouyang et al. - 2024 - Multi-Grained Specifications for Distributed System Model Checking and Verification.pdf:application/pdf;Snapshot:/home/georgefkd/Zotero/storage/DQZUBPDN/2409.html:text/html},
}

@article{amjad_semantics_2024,
	title = {Semantics for {Linear}-time {Temporal} {Logic} with {Finite} {Observations}},
	volume = {412},
	issn = {2075-2180},
	url = {http://arxiv.org/abs/2411.14581},
	doi = {10.4204/EPTCS.412.4},
	abstract = {LTL3 is a multi-valued variant of Linear-time Temporal Logic for runtime verification applications. The semantic descriptions of LTL3 in previous work are given only in terms of the relationship to conventional LTL. Our approach, by contrast, gives a full model-based inductive accounting of the semantics of LTL3, in terms of families of definitive prefix sets. We show that our definitive prefix sets are isomorphic to linear-time temporal properties (sets of infinite traces), and thereby show that our semantics of LTL3 directly correspond to the semantics of conventional LTL. In addition, we formalise the formula progression evaluation technique, popularly used in runtime verification and testing contexts, and show its soundness and completeness up to finite traces with respect to our semantics. All of our definitions and proofs are mechanised in Isabelle/HOL.},
	urldate = {2024-12-18},
	journal = {Electronic Proceedings in Theoretical Computer Science},
	author = {Amjad, Rayhana and Glabbeek, Rob van and O'Connor, Liam},
	month = nov,
	year = {2024},
	note = {arXiv:2411.14581 [cs]},
	keywords = {Computer Science - Logic in Computer Science},
	pages = {35--50},
	file = {Preprint PDF:/home/georgefkd/Zotero/storage/E5ZV2ILJ/Amjad et al. - 2024 - Semantics for Linear-time Temporal Logic with Finite Observations.pdf:application/pdf;Snapshot:/home/georgefkd/Zotero/storage/PT9PAGH3/2411.html:text/html},
}

@article{mackey_early_2024,
	title = {Early detection of temporal constraint violations},
	volume = {296},
	issn = {0890-5401},
	url = {https://www.sciencedirect.com/science/article/pii/S0890540123001177},
	doi = {10.1016/j.ic.2023.105114},
	abstract = {Software systems rely on events for logging, coordination, handling unusual situations, and more. Monitoring event streams from systems that provide services can ensure the service complies with policies, regulations, and other business rules. Notably, monitoring to detect violations of rules as early as possible is much desired as, for example, the service may reclaim more resources from erring enactments. The primary goal of this paper is to develop techniques for detecting violations of time constraints as early as possible. We formalize a model for events and a language to specify constraints on event timing and data. We develop algorithms to detect violations of individual rules, then use a chase process to detect violations of acyclic sets of rules. We also present optimization techniques to reduce monitoring overhead. Finally, we implement and evaluate our algorithms through experiments to demonstrate our approach is feasible and beneficial.},
	urldate = {2024-12-20},
	journal = {Information and Computation},
	author = {Mackey, Isaac and Chimni, Raghubir and Su, Jianwen},
	month = jan,
	year = {2024},
	pages = {105114},
	file = {Mackey et al. - 2024 - Early detection of temporal constraint violations.pdf:/home/georgefkd/Zotero/storage/3GHB8UTM/Mackey et al. - 2024 - Early detection of temporal constraint violations.pdf:application/pdf;ScienceDirect Snapshot:/home/georgefkd/Zotero/storage/MG7TKN3R/S0890540123001177.html:text/html},
}

@misc{klaedtke_polimon_2024,
	title = {{POLIMON}: {Checking} {Temporal} {Properties} over {Out}-of-order {Streams} at {Runtime}},
	shorttitle = {{POLIMON}},
	url = {http://arxiv.org/abs/2404.15723},
	doi = {10.48550/arXiv.2404.15723},
	abstract = {This paper presents the monitoring tool POLIMON for checking system behavior at runtime against specifications expressed as formulas in the real-time logic MTL or its extension with the freeze quantifier. The tool's distinguishing feature is that POLIMON can receive messages describing the system events out of order. Furthermore, since POLIMON processes received messages immediately, it outputs verdicts promptly when a message's described system event leads to a violation of the specification. This makes the tool well suited, e.g., for verifying the behavior of distributed systems with unreliable channels at runtime.},
	urldate = {2024-12-20},
	publisher = {arXiv},
	author = {Klaedtke, Felix},
	month = apr,
	year = {2024},
	note = {arXiv:2404.15723 [cs]},
	keywords = {Computer Science - Logic in Computer Science},
	file = {Preprint PDF:/home/georgefkd/Zotero/storage/H4GDN9Z9/Klaedtke - 2024 - POLIMON Checking Temporal Properties over Out-of-.pdf:application/pdf;Snapshot:/home/georgefkd/Zotero/storage/XJIHTJ8T/2404.html:text/html},
}

@article{jevitha_runtime_2024,
	title = {Runtime {Verification} on {Abstract} {Finite} {State} {Models}},
	volume = {216},
	issn = {01641212},
	url = {http://arxiv.org/abs/2406.12715},
	doi = {10.1016/j.jss.2024.112138},
	abstract = {Finite-state models are ubiquitous in the study of concurrent systems, especially controllers and servers that operate in a repetitive cycle. In this paper, we show how to extract finite state models from a run of a multi-threaded Java program and carry out runtime verification of correctness properties. These properties include data-oriented and control-oriented properties; the former express correctness conditions over the data fields of objects, while the latter are concerned with the correct flow of control among the modules of larger software. As the extracted models can become very large for long runs, the focus of this paper is on constructing reduced models with user-defined abstraction functions that map a larger domain space to a smaller one. The abstraction functions should be chosen so that the resulting model is property preserving, i.e., proving a property on the abstract model carries over to the concrete model. The main contribution of this paper is in showing how runtime verification can be made efficient through online property checking on property-preserving abstract models. The property specification language resembles a propositional linear temporal logic augmented with simple datatypes and operators. Classic concurrency examples and larger case studies (Multi-rotor Drone Controller, OAuth Protocol) are presented in order to demonstrate the usefulness of our proposed techniques, which are incorporated in an Eclipse plug-in for runtime visualization and verification of Java programs.},
	urldate = {2024-12-20},
	journal = {Journal of Systems and Software},
	author = {Jevitha, K. P. and Jayaraman, Bharat and Sethumadhavan, M.},
	month = oct,
	year = {2024},
	note = {arXiv:2406.12715 [cs]},
	keywords = {Computer Science - Performance, Computer Science - Software Engineering, Computer Science - Programming Languages},
	pages = {112138},
	file = {Preprint PDF:/home/georgefkd/Zotero/storage/BKVJIJGW/Jevitha et al. - 2024 - Runtime Verification on Abstract Finite State Mode.pdf:application/pdf;Snapshot:/home/georgefkd/Zotero/storage/VILWHWUQ/2406.html:text/html},
}

@inproceedings{tran_specification-based_2019,
	address = {New York, NY, USA},
	series = {{SoICT} '19},
	title = {A {Specification}-{Based} {Approach} to {Model} {Checking} {Event}-{Driven} {Systems}},
	isbn = {978-1-4503-7245-9},
	url = {https://dl.acm.org/doi/10.1145/3368926.3369703},
	doi = {10.1145/3368926.3369703},
	abstract = {An event-driven system with multiple external events is difficult to verify manually. Model checking is an appropriate approach for exhaustively and automatically verifying this kind of systems. In fact, adopting the specification language used by a specific model checker to specify the behaviors of the system is really hard because many events with the corresponding constraints need to be considered. To address this problem, we propose a domain-specific language (DSL) to facilitate the specification of an event-driven system with several configurations and validation rules for checking their properties. In our approach, the occurrences of these events can be defined using different scenarios. From the specification of the system, we generate the program in Promela (Process or Protocol Meta Language) for the verification. Model checking techniques are then applied to export the counterexamples as the results of the verification. From these results, we can handle the occurrence of the events to find the corresponding errors of the system.},
	urldate = {2024-12-20},
	booktitle = {Proceedings of the 10th {International} {Symposium} on {Information} and {Communication} {Technology}},
	publisher = {Association for Computing Machinery},
	author = {Tran, Nhat-Hoa},
	month = dec,
	year = {2019},
	pages = {449--456},
	file = {Full Text PDF:/home/georgefkd/Zotero/storage/DUDX7RKL/Tran - 2019 - A Specification-Based Approach to Model Checking E.pdf:application/pdf},
}

@article{van_der_aalst_replaying_2012,
	title = {Replaying history on process models for conformance checking and performance analysis},
	volume = {2},
	copyright = {Copyright © 2012 John Wiley \& Sons, Inc.},
	issn = {1942-4795},
	url = {https://onlinelibrary.wiley.com/doi/abs/10.1002/widm.1045},
	doi = {10.1002/widm.1045},
	abstract = {Process mining techniques use event data to discover process models, to check the conformance of predefined process models, and to extend such models with information about bottlenecks, decisions, and resource usage. These techniques are driven by observed events rather than hand-made models. Event logs are used to learn and enrich process models. By replaying history using the model, it is possible to establish a precise relationship between events and model elements. This relationship can be used to check conformance and to analyze performance. For example, it is possible to diagnose deviations from the modeled behavior. The severity of each deviation can be quantified. Moreover, the relationship established during replay and the timestamps in the event log can be combined to show bottlenecks. These examples illustrate the importance of maintaining a proper alignment between event log and process model. Therefore, we elaborate on the realization of such alignments and their application to conformance checking and performance analysis. © 2012 Wiley Periodicals, Inc. This article is categorized under: Algorithmic Development {\textgreater} Association Rules Algorithmic Development {\textgreater} Spatial and Temporal Data Mining Application Areas {\textgreater} Business and Industry Fundamental Concepts of Data and Knowledge {\textgreater} Data Concepts},
	language = {en},
	number = {2},
	urldate = {2025-01-01},
	journal = {WIREs Data Mining and Knowledge Discovery},
	author = {van der Aalst, Wil and Adriansyah, Arya and van Dongen, Boudewijn},
	year = {2012},
	note = {\_eprint: https://onlinelibrary.wiley.com/doi/pdf/10.1002/widm.1045},
	pages = {182--192},
	file = {Full Text PDF:/home/georgefkd/Zotero/storage/VFTSX7FD/van der Aalst et al. - 2012 - Replaying history on process models for conformance checking and performance analysis.pdf:application/pdf;Snapshot:/home/georgefkd/Zotero/storage/R5PJ2MLT/widm.html:text/html},
}

@article{atlee_state-based_1993,
	title = {State-based model checking of event-driven system requirements},
	volume = {19},
	issn = {1939-3520},
	url = {https://ieeexplore.ieee.org/abstract/document/210305},
	doi = {10.1109/32.210305},
	abstract = {It is demonstrated how model checking can be used to verify safety properties for event-driven systems. SCR tabular requirements describe required system behavior in a format that is intuitive, easy to read, and scalable to large systems (e.g. the software requirements for the A-7 military aircraft). Model checking of temporal logics has been established as a sound technique for verifying properties of hardware systems. An automated technique for formalizing the semiformal SCR requirements and for transforming the resultant formal specification onto a finite structure that a model checker can analyze has been developed. This technique was effective in uncovering violations of system invariants in both an automobile cruise control system and a water-level monitoring system.{\textless}{\textgreater}},
	number = {1},
	urldate = {2025-01-01},
	journal = {IEEE Transactions on Software Engineering},
	author = {Atlee, J.M. and Gannon, J.},
	month = jan,
	year = {1993},
	note = {Conference Name: IEEE Transactions on Software Engineering},
	keywords = {Hardware, Formal specifications, Logic, Automatic control, Automobiles, Control systems, Military aircraft, Safety, Software systems, Thyristors},
	pages = {24--40},
	file = {IEEE Xplore Abstract Record:/home/georgefkd/Zotero/storage/EHUUCAEM/210305.html:text/html},
}

@inproceedings{poroor_formal_2012,
	address = {Kollam India},
	title = {Formal analysis of event-driven cyber physical systems},
	isbn = {978-1-4503-1822-8},
	url = {https://dl.acm.org/doi/10.1145/2490428.2490429},
	doi = {10.1145/2490428.2490429},
	language = {en},
	urldate = {2025-01-01},
	booktitle = {Proceedings of the {First} {International} {Conference} on {Security} of {Internet} of {Things}},
	publisher = {ACM},
	author = {Poroor, Jayaraj and Jayaraman, Bharat},
	month = aug,
	year = {2012},
	pages = {1--8},
	file = {Available Version (via Google Scholar):/home/georgefkd/Zotero/storage/PPETNRNS/Poroor and Jayaraman - 2012 - Formal analysis of event-driven cyber physical systems.pdf:application/pdf},
}

@inproceedings{norstrom_timed_1999,
	title = {Timed automata as task models for event-driven systems},
	url = {https://ieeexplore.ieee.org/abstract/document/811218/},
	urldate = {2025-01-01},
	booktitle = {Proceedings {Sixth} {International} {Conference} on {Real}-{Time} {Computing} {Systems} and {Applications}. {RTCSA}'99 ({Cat}. {No}. {PR00306})},
	publisher = {IEEE},
	author = {Norstrom, Christer and Wall, Anders and Yi, Wang},
	year = {1999},
	pages = {182--189},
	file = {Available Version (via Google Scholar):/home/georgefkd/Zotero/storage/WD4M6XYN/Norstrom et al. - 1999 - Timed automata as task models for event-driven systems.pdf:application/pdf},
}

@article{mammar_formal_2024,
	title = {A formal approach for the correct deployment of cloud applications},
	volume = {232},
	url = {https://www.sciencedirect.com/science/article/pii/S0167642323001302},
	urldate = {2025-01-01},
	journal = {Science of Computer Programming},
	author = {Mammar, Amel and Belguidoum, Meriem and Hiba, Saddam Hocine},
	year = {2024},
	note = {Publisher: Elsevier},
	pages = {103048},
	file = {Available Version (via Google Scholar):/home/georgefkd/Zotero/storage/3XZ3KNRZ/Mammar et al. - 2024 - A formal approach for the correct deployment of cloud applications.pdf:application/pdf},
}

@inproceedings{tzialla_efficient_2024,
	address = {Athens Greece},
	title = {Efficient {Auditing} of {Event}-driven {Web} {Applications}},
	isbn = {979-8-4007-0437-6},
	url = {https://dl.acm.org/doi/10.1145/3627703.3650089},
	doi = {10.1145/3627703.3650089},
	language = {en},
	urldate = {2025-01-01},
	booktitle = {Proceedings of the {Nineteenth} {European} {Conference} on {Computer} {Systems}},
	publisher = {ACM},
	author = {Tzialla, Ioanna and Wang, Jeffery and Zhu, Jingyi and Panda, Aurojit and Walfish, Michael},
	month = apr,
	year = {2024},
	pages = {1208--1224},
	file = {Available Version (via Google Scholar):/home/georgefkd/Zotero/storage/M6R9ZZ5Q/Tzialla et al. - 2024 - Efficient Auditing of Event-driven Web Applications.pdf:application/pdf},
}

@inproceedings{kounev_methodology_2008,
	title = {A methodology for performance modeling of distributed event-based systems},
	url = {https://ieeexplore.ieee.org/abstract/document/4519556/},
	urldate = {2025-01-01},
	booktitle = {2008 11th {IEEE} {International} {Symposium} on {Object} and {Component}-{Oriented} {Real}-{Time} {Distributed} {Computing} ({ISORC})},
	publisher = {IEEE},
	author = {Kounev, Samuel and Sachs, Kai and Bacon, Jean and Buchmann, Alejandro},
	year = {2008},
	pages = {13--22},
	file = {Available Version (via Google Scholar):/home/georgefkd/Zotero/storage/B5KDVYPH/Kounev et al. - 2008 - A methodology for performance modeling of distributed event-based systems.pdf:application/pdf},
}

@inproceedings{grabs_measuring_2012,
	address = {Berlin, Heidelberg},
	title = {Measuring {Performance} of {Complex} {Event} {Processing} {Systems}},
	isbn = {978-3-642-32627-1},
	doi = {10.1007/978-3-642-32627-1_6},
	abstract = {Complex Event Processing (CEP) or stream data processing are becoming increasingly popular as the platform underlying event-driven solutions and applications in industries such as financial services, oil \& gas, smart grids, health care, and IT monitoring. Satisfactory performance is crucial for any solution across these industries. Typically, performance of CEP engines is measured as (1) data rate, i.e., number of input events processed per second, and (2) latency, which denotes the time it takes for the result (output events) to emerge from the system after the business event (input event) happened. While data rates are typically easy to measure by capturing the numbers of input events over time, latency is less well defined. As it turns out, a definition becomes particularly challenging in the presence of data arriving out of order. That means that the order in which events arrive at the system is different from the order of their timestamps. Many important distributed scenarios need to deal with out-of-order arrival because communication delays easily introduce disorder.},
	language = {en},
	booktitle = {Topics in {Performance} {Evaluation}, {Measurement} and {Characterization}},
	publisher = {Springer},
	author = {Grabs, Torsten and Lu, Ming},
	editor = {Nambiar, Raghunath and Poess, Meikel},
	year = {2012},
	keywords = {Benchmark Definition, CEP, Complex Event Processing, Data Rate, Information Latency, Latency, Performance Evaluation, System Latency},
	pages = {83--96},
	file = {Full Text PDF:/home/georgefkd/Zotero/storage/9EXQUMKD/Grabs and Lu - 2012 - Measuring Performance of Complex Event Processing Systems.pdf:application/pdf},
}

@inproceedings{malthora_metric_2023,
	title = {Metric {Suite} for {Event}-{Driven} {Software} {Systems}},
	url = {https://ieeexplore.ieee.org/abstract/document/10466151?casa_token=ELbcsVHWrlYAAAAA:agjnSaaCg1whP0rXnbsaZrlQymkxHOED04dGzeQDlvQsWnNu9wesiNxMnf4sLIcnOX_Iamom8Oc},
	doi = {10.1109/ICAICCIT60255.2023.10466151},
	abstract = {Event-driven software systems have gained significant prominence due to their ability to handle complex and asynchronous interactions. Evaluating the quality and characteristics of such systems is crucial to ensure their reliability and efficiency. This research paper proposes a comprehensive set of metrics specifically designed to measure event-driven software systems. Beginning with an exposition of the event-driven programming paradigm, this study emphasizes its pivotal traits, highlighting the distinctiveness of event-driven systems in contrast to structured and object-oriented programming paradigms. The purpose of this research paper is to address the necessity for metrics tailored to event-driven systems. The proposed metrics are grouped into categories, such as event structure, event dependency, event performance, event complexity, event synchronization and event reliability metrics. Each metric is defined and described. These metrics facilitate software practitioners to make informed decisions during system design, optimization, and evaluation processes. The research paper concludes by discussing the limitations of the study, including potential threats to its validity. Future guidelines are also outlined, highlighting opportunities for further research, industry adoption, tooling, benchmarking, and continuous improvement of the proposed metrics.},
	urldate = {2025-01-01},
	booktitle = {2023 {International} {Conference} on {Advances} in {Computation}, {Communication} and {Information} {Technology} ({ICAICCIT})},
	author = {Malthora, Ruchika and Cherukuri, Madhukar},
	month = nov,
	year = {2023},
	keywords = {Measurement, Software systems, Benchmark testing, Complexity theory, event-driven programming (EDP), Industries, software measurement, software metrics, software quality, Software reliability, Synchronization},
	pages = {1140--1145},
	file = {Full Text PDF:/home/georgefkd/Zotero/storage/LUF86P9G/Malthora and Cherukuri - 2023 - Metric Suite for Event-Driven Software Systems.pdf:application/pdf;IEEE Xplore Abstract Record:/home/georgefkd/Zotero/storage/DSCV4AMI/10466151.html:text/html},
}

@article{sachs_performance_2013,
	title = {Performance modeling and analysis of message-oriented event-driven systems},
	volume = {12},
	url = {https://idp.springer.com/authorize/casa?redirect_uri=https://link.springer.com/article/10.1007/s10270-012-0228-1&casa_token=OHwNtXpW3kQAAAAA:BRnghfArx62AQS3qPK3zXbv3g9wYEj-poyIL9tOY0zm0ypdRiMr8Fs9nuY9cHvk8LQS-4_uQISdDiOVzsQ},
	urldate = {2025-01-01},
	journal = {Software \& Systems Modeling},
	author = {Sachs, Kai and Kounev, Samuel and Buchmann, Alejandro},
	year = {2013},
	note = {Publisher: Springer},
	pages = {705--729},
	file = {Available Version (via Google Scholar):/home/georgefkd/Zotero/storage/HYLARYAB/Sachs et al. - 2013 - Performance modeling and analysis of message-oriented event-driven systems.pdf:application/pdf},
}

@incollection{hutchison_event-driven_2008,
	address = {Berlin, Heidelberg},
	title = {Event-{Driven} {Quality} of {Service} {Prediction}},
	volume = {4749},
	copyright = {http://www.springer.com/tdm},
	isbn = {978-3-540-74973-8 978-3-540-74974-5},
	url = {http://link.springer.com/10.1007/978-3-540-89652-4_14},
	urldate = {2025-01-01},
	booktitle = {Service-{Oriented} {Computing} – {ICSOC} 2007},
	publisher = {Springer Berlin Heidelberg},
	author = {Zeng, Liangzhao and Lingenfelder, Christoph and Lei, Hui and Chang, Henry},
	editor = {Hutchison, David and Kanade, Takeo and Kittler, Josef and Kleinberg, Jon M. and Mattern, Friedemann and Mitchell, John C. and Naor, Moni and Nierstrasz, Oscar and Pandu Rangan, C. and Steffen, Bernhard and Sudan, Madhu and Terzopoulos, Demetri and Tygar, Doug and Vardi, Moshe Y. and Weikum, Gerhard and Krämer, Bernd J. and Lin, Kwei-Jay and Narasimhan, Priya},
	year = {2008},
	doi = {10.1007/978-3-540-89652-4_14},
	note = {Series Title: Lecture Notes in Computer Science},
	pages = {147--161},
	file = {Full Text:/home/georgefkd/Zotero/storage/V45A3HE6/Zeng et al. - 2008 - Event-Driven Quality of Service Prediction.pdf:application/pdf},
}

@inproceedings{malthora_metric_2023-1,
	title = {Metric {Suite} for {Event}-{Driven} {Software} {Systems}},
	url = {https://ieeexplore.ieee.org/abstract/document/10466151/?casa_token=ELbcsVHWrlYAAAAA:agjnSaaCg1whP0rXnbsaZrlQymkxHOED04dGzeQDlvQsWnNu9wesiNxMnf4sLIcnOX_Iamom8Oc},
	urldate = {2025-01-01},
	booktitle = {2023 {International} {Conference} on {Advances} in {Computation}, {Communication} and {Information} {Technology} ({ICAICCIT})},
	publisher = {IEEE},
	author = {Malthora, Ruchika and Cherukuri, Madhukar},
	year = {2023},
	pages = {1140--1145},
}

@incollection{hutchison_measuring_2012,
	address = {Berlin, Heidelberg},
	title = {Measuring {Performance} of {Complex} {Event} {Processing} {Systems}},
	volume = {7144},
	isbn = {978-3-642-32626-4 978-3-642-32627-1},
	url = {http://link.springer.com/10.1007/978-3-642-32627-1_6},
	urldate = {2025-01-01},
	booktitle = {Topics in {Performance} {Evaluation}, {Measurement} and {Characterization}},
	publisher = {Springer Berlin Heidelberg},
	author = {Grabs, Torsten and Lu, Ming},
	editor = {Hutchison, David and Kanade, Takeo and Kittler, Josef and Kleinberg, Jon M. and Mattern, Friedemann and Mitchell, John C. and Naor, Moni and Nierstrasz, Oscar and Pandu Rangan, C. and Steffen, Bernhard and Sudan, Madhu and Terzopoulos, Demetri and Tygar, Doug and Vardi, Moshe Y. and Weikum, Gerhard and Nambiar, Raghunath and Poess, Meikel},
	year = {2012},
	doi = {10.1007/978-3-642-32627-1_6},
	note = {Series Title: Lecture Notes in Computer Science},
	pages = {83--96},
}

@incollection{cotroneo_towards_2021,
	title = {Towards {Runtime} {Verification} via {Event} {Stream} {Processing} in {Cloud} {Computing} {Infrastructures}},
	volume = {12632},
	url = {http://arxiv.org/abs/2010.06607},
	abstract = {Software bugs in cloud management systems often cause erratic behavior, hindering detection, and recovery of failures. As a consequence, the failures are not timely detected and notified, and can silently propagate through the system. To face these issues, we propose a lightweight approach to runtime verification, for monitoring and failure detection of cloud computing systems. We performed a preliminary evaluation of the proposed approach in the OpenStack cloud management platform, an "off-the-shelf" distributed system, showing that the approach can be applied with high failure detection coverage.},
	urldate = {2025-01-01},
	author = {Cotroneo, Domenico and Simone, Luigi De and Liguori, Pietro and Natella, Roberto and Scibelli, Angela},
	year = {2021},
	doi = {10.1007/978-3-030-76352-7_19},
	note = {arXiv:2010.06607 [cs]},
	keywords = {Computer Science - Software Engineering},
	pages = {162--175},
	file = {Preprint PDF:/home/georgefkd/Zotero/storage/P4LZLBBD/Cotroneo et al. - 2021 - Towards Runtime Verification via Event Stream Processing in Cloud Computing Infrastructures.pdf:application/pdf;Snapshot:/home/georgefkd/Zotero/storage/3QH2DBI3/2010.html:text/html},
}

@article{thati_monitoring_2005,
	title = {Monitoring {Algorithms} for {Metric} {Temporal} {Logic} {Specifications}},
	volume = {113},
	copyright = {https://www.elsevier.com/tdm/userlicense/1.0/},
	issn = {15710661},
	url = {https://linkinghub.elsevier.com/retrieve/pii/S1571066104052570},
	doi = {10.1016/j.entcs.2004.01.029},
	abstract = {Program execution traces can be so large in practical testing and monitoring applications that it would be very expensive, if not impossible, to store them for detailed analysis. Monitoring execution traces without storing them, can be a nontrivial matter for many speciﬁcation formalisms, because complex formulae may require a considerable amount of information about the past. Metric temporal logic (MTL) is an extension of propositional linear temporal logic with discrete-time-bounded temporal operators. In MTL, one can specify time limits within which certain temporal properties must hold, thus making it very suitable to express real-time monitoring requirements. In this paper, we present monitoring algorithms for checking timestamped execution traces against formulae in MTL or certain important sublogics of it. We also present lower bounds for the monitoring problem, showing that the presented algorithms are asymptotically optimal.},
	language = {en},
	urldate = {2025-01-01},
	journal = {Electronic Notes in Theoretical Computer Science},
	author = {Thati, Prasanna and Roşu, Grigore},
	month = jan,
	year = {2005},
	pages = {145--162},
	file = {PDF:/home/georgefkd/Zotero/storage/7V2LIZT9/Thati and Roşu - 2005 - Monitoring Algorithms for Metric Temporal Logic Specifications.pdf:application/pdf},
}

@article{holzmann_practical_nodate,
	title = {A {Practical} {Method} for {Verifying} {Event}-{Driven} {Software}},
	language = {en},
	author = {Holzmann, Gerard J and Smith, Margaret H},
	file = {PDF:/home/georgefkd/Zotero/storage/D9KCZWX7/Holzmann and Smith - A Practical Method for Verifying Event-Driven Software.pdf:application/pdf},
}

@article{koymans_specifying_1990,
	title = {Specifying real-time properties with metric temporal logic},
	volume = {2},
	issn = {1573-1383},
	url = {https://doi.org/10.1007/BF01995674},
	doi = {10.1007/BF01995674},
	abstract = {This paper is motivated by the need for a formal specification method for real-time systems. In these systemsquantitative temporal properties play a dominant role. We first characterize real-time systems by giving a classification of such quantitative temporal properties. Next, we extend the usual models for temporal logic by including a distance function to measure time and analyze what restrictions should be imposed on such a function. Then we introduce appropriate temporal operators to reason about such models by turning qualitative temporal operators into (quantitative) metric temporal operators and show how the usual quantitative temporal properties of real-time systems can be expressed in this metric temporal logic. After we illustrate the application of metric temporal logic to real-time systems by several examples, we end this paper with some conclusions.},
	language = {en},
	number = {4},
	urldate = {2025-01-01},
	journal = {Real-Time Systems},
	author = {Koymans, Ron},
	month = nov,
	year = {1990},
	keywords = {Distance Function, Dominant Role, Formal Specification, System Performance, Temporal Operator},
	pages = {255--299},
	file = {Full Text PDF:/home/georgefkd/Zotero/storage/2QGIFX4T/Koymans - 1990 - Specifying real-time properties with metric temporal logic.pdf:application/pdf},
}

@incollection{bonfanti_formal_2024,
	address = {Cham},
	title = {Formal {Modeling} and {Analysis} of {Apache} {Kafka} in {Alloy} 6},
	volume = {14759},
	isbn = {978-3-031-63789-6 978-3-031-63790-2},
	url = {https://link.springer.com/10.1007/978-3-031-63790-2_2},
	language = {en},
	urldate = {2024-12-30},
	booktitle = {Rigorous {State}-{Based} {Methods}},
	publisher = {Springer Nature Switzerland},
	author = {Sinha, Saloni and Kang, Eunsuk},
	editor = {Bonfanti, Silvia and Gargantini, Angelo and Leuschel, Michael and Riccobene, Elvinia and Scandurra, Patrizia},
	year = {2024},
	doi = {10.1007/978-3-031-63790-2_2},
	note = {Series Title: Lecture Notes in Computer Science},
	pages = {25--42},
}

@article{xavier_framework_2024,
	title = {A {Framework} for the {Generation} of {Monitor} and {Plant} {Model} {From} {Event} {Logs} {Using} {Process} {Mining} for {Formal} {Verification} of {Event}-{Driven} {Systems}},
	volume = {5},
	issn = {2644-1284},
	url = {https://ieeexplore.ieee.org/document/10550182/?arnumber=10550182},
	doi = {10.1109/OJIES.2024.3406059},
	abstract = {This article proposes a method for the automatic generation of a plant model and monitoring using process mining algorithms based on recorded event logs. The behavioral traces of the system are captured by recording event logs during plant operation in either manual control mode or with an automatic controller. Process discovery algorithms are then applied to extract the logic of the process behavior properties from the recorded event logs. The result is represented as a Petri net, which is used to construct the state machine of the plant model and monitor and is in accordance with the IEC 61499 Standard. The monitor is implemented as a function block and can be deployed in real time to trigger an error signal whenever there is a deviation from the actual process scenario. The plant model and controller are connected in a closed loop and are used for the formal verification of the system with the help of the “fb2smv” converter and symbolic model checking tool NuSMV.},
	urldate = {2024-12-30},
	journal = {IEEE Open Journal of the Industrial Electronics Society},
	author = {Xavier, Midhun and Dubinin, Victor and Patil, Sandeep and Vyatkin, Valeriy},
	year = {2024},
	note = {Conference Name: IEEE Open Journal of the Industrial Electronics Society},
	keywords = {Monitoring, Automation, Standards, Formal verification, Decentralized control, formal verification, IEC 61499, IEC Standards, plant model generation, Process control, process mining},
	pages = {517--534},
	file = {Full Text PDF:/home/georgefkd/Zotero/storage/VB4ABH7I/Xavier et al. - 2024 - A Framework for the Generation of Monitor and Plant Model From Event Logs Using Process Mining for F.pdf:application/pdf;IEEE Xplore Abstract Record:/home/georgefkd/Zotero/storage/JYVDLSTQ/10550182.html:text/html},
}

@misc{noauthor_diagnosis_nodate,
	title = {Diagnosis of {Time}-{Sensitive} {Failures} in {Timed} {Discrete}-{Event} {Systems} with {Metric} {Interval} {Temporal} {Logics} {\textbar} {IEEE} {Conference} {Publication} {\textbar} {IEEE} {Xplore}},
	url = {https://ieeexplore.ieee.org/abstract/document/10383314?casa_token=2xBb_33vYE0AAAAA:ZYs0I6oOwzJC5-jB-GsFul4VTvTe4GNCbUSqlCQ8EKnTPqpMshgNUoiKQ8tttxs1Hz3QrBxo5K4},
	urldate = {2024-12-29},
	file = {Diagnosis of Time-Sensitive Failures in Timed Discrete-Event Systems with Metric Interval Temporal Logics | IEEE Conference Publication | IEEE Xplore:/home/georgefkd/Zotero/storage/YY4PJUBX/10383314.html:text/html},
}

@inproceedings{dong_diagnosis_2023,
	title = {Diagnosis of {Time}-{Sensitive} {Failures} in {Timed} {Discrete}-{Event} {Systems} with {Metric} {Interval} {Temporal} {Logics}},
	url = {https://ieeexplore.ieee.org/abstract/document/10383314/?casa_token=2xBb_33vYE0AAAAA:ZYs0I6oOwzJC5-jB-GsFul4VTvTe4GNCbUSqlCQ8EKnTPqpMshgNUoiKQ8tttxs1Hz3QrBxo5K4},
	urldate = {2024-12-29},
	booktitle = {2023 62nd {IEEE} {Conference} on {Decision} and {Control} ({CDC})},
	publisher = {IEEE},
	author = {Dong, Weijie and Li, Shaoyuan and Yin, Xiang},
	year = {2023},
	pages = {6827--6833},
	file = {PDF:/home/georgefkd/Zotero/storage/I3MLNLGU/Dong et al. - 2023 - Diagnosis of Time-Sensitive Failures in Timed Discrete-Event Systems with Metric Interval Temporal L.pdf:application/pdf},
}

@incollection{ogata_towards_2016,
	address = {Cham},
	title = {Towards the {Formal} {Verification} of {Data}-{Intensive} {Applications} {Through} {Metric} {Temporal} {Logic}},
	volume = {10009},
	copyright = {http://www.springer.com/tdm},
	isbn = {978-3-319-47845-6 978-3-319-47846-3},
	url = {http://link.springer.com/10.1007/978-3-319-47846-3_13},
	urldate = {2024-12-29},
	booktitle = {Formal {Methods} and {Software} {Engineering}},
	publisher = {Springer International Publishing},
	author = {Marconi, Francesco and Bersani, Marcello M. and Erascu, Madalina and Rossi, Matteo},
	editor = {Ogata, Kazuhiro and Lawford, Mark and Liu, Shaoying},
	year = {2016},
	doi = {10.1007/978-3-319-47846-3_13},
	note = {Series Title: Lecture Notes in Computer Science},
	pages = {193--209},
	file = {Available Version (via Google Scholar):/home/georgefkd/Zotero/storage/I2DTXBAX/Marconi et al. - 2016 - Towards the Formal Verification of Data-Intensive Applications Through Metric Temporal Logic.pdf:application/pdf},
}

@inproceedings{newcombe_why_2014,
	address = {Berlin, Heidelberg},
	title = {Why {Amazon} {Chose} {TLA} +},
	isbn = {978-3-662-43652-3},
	doi = {10.1007/978-3-662-43652-3_3},
	abstract = {Since 2011, engineers at Amazon have been using TLA +  to help solve difficult design problems in critical systems. This paper describes the reasons why we chose TLA +  instead of other methods, and areas in which we would welcome further progress.},
	language = {en},
	booktitle = {Abstract {State} {Machines}, {Alloy}, {B}, {TLA}, {VDM}, and {Z}},
	publisher = {Springer},
	author = {Newcombe, Chris},
	editor = {Ait Ameur, Yamine and Schewe, Klaus-Dieter},
	year = {2014},
	keywords = {Linear Temporal Logic, Model Checker, Proof System, Safety Property, Temporal Logic},
	pages = {25--39},
	file = {Full Text PDF:/home/georgefkd/Zotero/storage/J6CYGZ8V/Newcombe - 2014 - Why Amazon Chose TLA +.pdf:application/pdf},
}

@incollection{hutchison_why_2014,
	address = {Berlin, Heidelberg},
	title = {Why {Amazon} {Chose} {TLA} +},
	volume = {8477},
	isbn = {978-3-662-43651-6 978-3-662-43652-3},
	url = {http://link.springer.com/10.1007/978-3-662-43652-3_3},
	urldate = {2024-12-28},
	booktitle = {Abstract {State} {Machines}, {Alloy}, {B}, {TLA}, {VDM}, and {Z}},
	publisher = {Springer Berlin Heidelberg},
	author = {Newcombe, Chris},
	editor = {Hutchison, David and Kanade, Takeo and Kittler, Josef and Kleinberg, Jon M. and Kobsa, Alfred and Mattern, Friedemann and Mitchell, John C. and Naor, Moni and Nierstrasz, Oscar and Pandu Rangan, C. and Steffen, Bernhard and Terzopoulos, Demetri and Tygar, Doug and Weikum, Gerhard and Ait Ameur, Yamine and Schewe, Klaus-Dieter},
	year = {2014},
	doi = {10.1007/978-3-662-43652-3_3},
	note = {Series Title: Lecture Notes in Computer Science},
	pages = {25--39},
}

@article{chong_codelevel_2021,
	title = {Code‐level model checking in the software development workflow at {Amazon} {Web} {Services}},
	volume = {51},
	issn = {0038-0644, 1097-024X},
	url = {https://onlinelibrary.wiley.com/doi/10.1002/spe.2949},
	doi = {10.1002/spe.2949},
	abstract = {Abstract
            This article describes a style of applying symbolic model checking developed over the course of four years at Amazon Web Services (AWS). Lessons learned are drawn from proving properties of numerous C‐based systems, for example, custom hypervisors, encryption code, boot loaders, and an IoT operating system. Using our methodology, we find that we can prove the correctness of industrial low‐level C‐based systems with reasonable effort and predictability. Furthermore, AWS developers are increasingly writing their own formal specifications. As part of this effort, we have developed a CI system that allows integration of the proofs into standard development workflows and extended the proof tools to provide better feedback to users. All proofs discussed in this article are publicly available on GitHub.},
	language = {en},
	number = {4},
	urldate = {2024-12-28},
	journal = {Software: Practice and Experience},
	author = {Chong, Nathan and Cook, Byron and Eidelman, Jonathan and Kallas, Konstantinos and Khazem, Kareem and Monteiro, Felipe R. and Schwartz‐Narbonne, Daniel and Tasiran, Serdar and Tautschnig, Michael and Tuttle, Mark R.},
	month = apr,
	year = {2021},
	pages = {772--797},
	file = {Full Text:/home/georgefkd/Zotero/storage/UQHZXMT6/Chong et al. - 2021 - Code‐level model checking in the software development workflow at Amazon Web Services.pdf:application/pdf},
}

@article{newcombe_use_2014,
	title = {Use of formal methods at {Amazon} {Web} {Services}},
	url = {https://6826.csail.mit.edu/2019/papers/formal-methods-amazon.pdf},
	urldate = {2024-12-28},
	journal = {See http://research. microsoft. com/en-us/um/people/lamport/tla/formal-methods-amazon. pdf},
	author = {Newcombe, Chris and Rath, Tim and Zhang, Fan and Munteanu, Bogdan and Brooker, Marc and Deardeuff, Michael},
	year = {2014},
	pages = {16},
	file = {Available Version (via Google Scholar):/home/georgefkd/Zotero/storage/ATK8DV85/Newcombe et al. - 2014 - Use of formal methods at Amazon Web Services.pdf:application/pdf},
}

@article{newcombe_how_2015,
	title = {How {Amazon} web services uses formal methods},
	volume = {58},
	issn = {0001-0782, 1557-7317},
	url = {https://dl.acm.org/doi/10.1145/2699417},
	doi = {10.1145/2699417},
	abstract = {Engineers use TLA+ to prevent serious but subtle bugs from reaching production.},
	language = {en},
	number = {4},
	urldate = {2024-12-28},
	journal = {Communications of the ACM},
	author = {Newcombe, Chris and Rath, Tim and Zhang, Fan and Munteanu, Bogdan and Brooker, Marc and Deardeuff, Michael},
	month = mar,
	year = {2015},
	pages = {66--73},
	file = {Available Version (via Google Scholar):/home/georgefkd/Zotero/storage/LR5Y53EJ/Newcombe et al. - 2015 - How Amazon web services uses formal methods.pdf:application/pdf},
}

@inproceedings{bornholt_using_2021,
	address = {Virtual Event Germany},
	title = {Using {Lightweight} {Formal} {Methods} to {Validate} a {Key}-{Value} {Storage} {Node} in {Amazon} {S3}},
	isbn = {978-1-4503-8709-5},
	url = {https://dl.acm.org/doi/10.1145/3477132.3483540},
	doi = {10.1145/3477132.3483540},
	language = {en},
	urldate = {2024-12-28},
	booktitle = {Proceedings of the {ACM} {SIGOPS} 28th {Symposium} on {Operating} {Systems} {Principles}},
	publisher = {ACM},
	author = {Bornholt, James and Joshi, Rajeev and Astrauskas, Vytautas and Cully, Brendan and Kragl, Bernhard and Markle, Seth and Sauri, Kyle and Schleit, Drew and Slatton, Grant and Tasiran, Serdar and Van Geffen, Jacob and Warfield, Andrew},
	month = oct,
	year = {2021},
	pages = {836--850},
	file = {Available Version (via Google Scholar):/home/georgefkd/Zotero/storage/TJPBJH6V/Bornholt et al. - 2021 - Using Lightweight Formal Methods to Validate a Key-Value Storage Node in Amazon S3.pdf:application/pdf},
}

@article{allen_maintaining_1983,
	title = {Maintaining knowledge about temporal intervals},
	volume = {26},
	issn = {0001-0782, 1557-7317},
	url = {https://dl.acm.org/doi/10.1145/182.358434},
	doi = {10.1145/182.358434},
	language = {en},
	number = {11},
	urldate = {2024-12-26},
	journal = {Communications of the ACM},
	author = {Allen, James F.},
	month = nov,
	year = {1983},
	pages = {832--843},
	file = {Available Version (via Google Scholar):/home/georgefkd/Zotero/storage/UHTBV3CL/Allen - 1983 - Maintaining knowledge about temporal intervals.pdf:application/pdf},
}

@article{ganguly_distributed_2024,
	title = {Distributed runtime verification of metric temporal properties},
	volume = {185},
	issn = {0743-7315},
	url = {https://www.sciencedirect.com/science/article/pii/S0743731523001715},
	doi = {10.1016/j.jpdc.2023.104801},
	abstract = {Distributed Systems are often composed of geographically separated components, where the clocks may not be perfectly synchronized. As such verifying the correctness of such system properties are a major challenge and are of utmost importance. In this paper, we describe a centralized runtime monitoring technique for distributed system. First, we propose a generalized runtime verification technique for verifying partially synchronous distributed computations for the metric temporal logic (MTL) by exploiting bounded-skew clock synchronization. Second, we introduce a progression-based formula rewriting scheme for monitoring MTL specifications which employs SMT solving techniques and report experimental results. Third, we also quantify each event according to the possible time of occurrence and calculate the probabilistic guarantee for generating the verification verdict. Lastly, we have implemented the entire procedure and report on extensive synthetic experimental results using UPPAAL, a set of cross-chain transactions implemented on Ethereum and an Industrial Control System of a water treatment plant.},
	urldate = {2024-12-25},
	journal = {Journal of Parallel and Distributed Computing},
	author = {Ganguly, Ritam and Xue, Yingjie and Jonckheere, Aaron and Ljung, Parker and Schornstein, Benjamin and Bonakdarpour, Borzoo and Herlihy, Maurice},
	month = mar,
	year = {2024},
	keywords = {Runtime verification, Cross-chain protocols, Distributed systems, Metric temporal logic, Partial synchrony},
	pages = {104801},
	file = {PDF:/home/georgefkd/Zotero/storage/BJ5T4NGP/Ganguly et al. - 2024 - Distributed runtime verification of metric temporal properties.pdf:application/pdf;ScienceDirect Snapshot:/home/georgefkd/Zotero/storage/VU7EFCGX/S0743731523001715.html:text/html},
}

@article{rozier_linear_2011,
	title = {Linear {Temporal} {Logic} {Symbolic} {Model} {Checking}},
	volume = {5},
	issn = {1574-0137},
	url = {https://www.sciencedirect.com/science/article/pii/S1574013710000407},
	doi = {10.1016/j.cosrev.2010.06.002},
	abstract = {We are seeing an increased push in the use of formal verification techniques in safety-critical software and hardware in practice. Formal verification has been successfully used to verify systems such as air traffic control, airplane separation assurance, autopilot, CPU designs, life-support systems, medical equipment (such as devices which administer radiation), and many other systems which ensure human safety. This survey provides a perspective on the formal verification technique of linear temporal logic (LTL) symbolic model checking, from its history and evolution leading up to the state-of-the-art. We unify research from 1977 to 2009, providing a complete end-to-end analysis embracing a users’ perspective by applying each step to a real-life aerospace example. We include an in-depth examination of the algorithms underlying the symbolic model-checking procedure, show proofs of important theorems, and point to directions of ongoing research. The primary focus is on model checking using LTL specifications, though other approaches are briefly discussed and compared to using LTL.},
	number = {2},
	urldate = {2024-12-23},
	journal = {Computer Science Review},
	author = {Rozier, Kristin Y.},
	month = may,
	year = {2011},
	keywords = {Formal Methods, Linear Temporal Logic (LTL), Symbolic Model Checking (SMC), Verification},
	pages = {163--203},
	file = {Rozier - 2011 - Linear Temporal Logic Symbolic Model Checking.pdf:/home/georgefkd/Zotero/storage/JF6XIDI9/Rozier - 2011 - Linear Temporal Logic Symbolic Model Checking.pdf:application/pdf;ScienceDirect Snapshot:/home/georgefkd/Zotero/storage/HAET4NZP/S1574013710000407.html:text/html},
}

@inproceedings{lamport_what_1983,
	title = {What good is temporal logic?},
	volume = {83},
	url = {https://lamport.azurewebsites.net/pubs/what-good.pdf},
	urldate = {2024-12-23},
	booktitle = {{IFIP} congress},
	author = {Lamport, Leslie},
	year = {1983},
	pages = {657--668},
	file = {Available Version (via Google Scholar):/home/georgefkd/Zotero/storage/Q9W6BWJN/Lamport - 1983 - What good is temporal logic.pdf:application/pdf},
}

@article{clarke_model_2009,
	title = {Model checking: algorithmic verification and debugging},
	volume = {52},
	issn = {0001-0782, 1557-7317},
	shorttitle = {Model checking},
	url = {https://dl.acm.org/doi/10.1145/1592761.1592781},
	doi = {10.1145/1592761.1592781},
	abstract = {Turing Lecture from the winners of the 2007 ACM A.M. Turing Award.
            In 1981, Edmund M. Clarke and E. Allen Emerson, working in the USA, and Joseph Sifakis working independently in France, authored seminal papers that founded what has become the highly successful field of model checking. This verification technology provides an algorithmic means of determining whether an abstract model---representing, for example, a hardware or software design---satisfies a formal specification expressed as a temporal logic (TL) formula. Moreover, if the property does not hold, the method identifies a counterexample execution that shows the source of the problem.
            The progression of model checking to the point where it can be successfully used for complex systems has required the development of sophisticated means of coping with what is known as the state explosion problem. Great strides have been made on this problem over the past 28 years by what is now a very large international research community. As a result many major hardware and software companies are beginning to use model checking in practice. Examples of its use include the verification of VLSI circuits, communication protocols, software device drivers, real-time embedded systems, and security algorithms.
            The work of Clarke, Emerson, and Sifakis continues to be central to the success of this research area. Their work over the years has led to the creation of new logics for specification, new verification algorithms, and surprising theoretical results. Model checking tools, created by both academic and industrial teams, have resulted in an entirely novel approach to verification and test case generation. This approach, for example, often enables engineers in the electronics industry to design complex systems with considerable assurance regarding the correctness of their initial designs. Model checking promises to have an even greater impact on the hardware and software industries in the future.
            
                      ---
              Moshe Y. Vardi, Editor-in-Chief},
	language = {en},
	number = {11},
	urldate = {2024-12-23},
	journal = {Communications of the ACM},
	author = {Clarke, Edmund M. and Emerson, E. Allen and Sifakis, Joseph},
	month = nov,
	year = {2009},
	pages = {74--84},
	file = {Available Version (via Google Scholar):/home/georgefkd/Zotero/storage/WB9VNWLF/Clarke et al. - 2009 - Model checking algorithmic verification and debug.pdf:application/pdf},
}

@inproceedings{pnueli_temporal_1977,
	title = {The temporal logic of programs},
	url = {https://ieeexplore.ieee.org/abstract/document/4567924},
	doi = {10.1109/SFCS.1977.32},
	abstract = {A unified approach to program verification is suggested, which applies to both sequential and parallel programs. The main proof method suggested is that of temporal reasoning in which the time dependence of events is the basic concept. Two formal systems are presented for providing a basis for temporal reasoning. One forms a formalization of the method of intermittent assertions, while the other is an adaptation of the tense logic system Kb, and is particularly suitable for reasoning about concurrent programs.},
	urldate = {2024-12-23},
	booktitle = {18th {Annual} {Symposium} on {Foundations} of {Computer} {Science} (sfcs 1977)},
	author = {Pnueli, Amir},
	month = oct,
	year = {1977},
	note = {ISSN: 0272-5428},
	keywords = {Logic, Safety, Clocks, Operating systems, Power system modeling, Programming profession, Real time systems, Reasoning about programs, Stress, System recovery},
	pages = {46--57},
	file = {IEEE Xplore Abstract Record:/home/georgefkd/Zotero/storage/CCDZ5SXZ/4567924.html:text/html},
}

@inproceedings{hendriks_checking_2016,
	address = {Torun, Poland},
	title = {Checking {Metric} {Temporal} {Logic} with {TRACE}},
	isbn = {978-1-5090-2589-3},
	url = {http://ieeexplore.ieee.org/document/7842497/},
	doi = {10.1109/ACSD.2016.13},
	abstract = {Execution traces, time-stamped sequences of events, provide a general, domain-independent, view on the behavior of systems. They enable analysis of metrics such as latency, pipeline depth and throughput. Often, however, it is not clear what such metrics exactly mean and ad hoc methods are used to compute them. Metric Temporal Logic (MTL) can be used to address this issue: it enables the formal speciﬁcation of quantitative properties on execution traces. We thus have added an MTL checking capability to the TRACE tool, which is a tool for viewing and analyzing execution traces [1]. We use a recursive memoization algorithm that generates concise explanations of the truth value of the given MTL formula. These explanations can be visualized in the TRACE viewer to aid interpretation by the user.},
	language = {en},
	urldate = {2025-01-07},
	booktitle = {2016 16th {International} {Conference} on {Application} of {Concurrency} to {System} {Design} ({ACSD})},
	publisher = {IEEE},
	author = {Hendriks, Martijn and Geilen, Marc and Behrouzian, Amir R. B. and Basten, Twan and Alizadeh, Hadi and Goswami, Dip},
	month = jun,
	year = {2016},
	pages = {19--24},
	file = {PDF:/home/georgefkd/Zotero/storage/JE7CWB8F/Hendriks et al. - 2016 - Checking Metric Temporal Logic with TRACE.pdf:application/pdf},
}

@inproceedings{dong_diagnosis_2023-1,
	address = {Singapore, Singapore},
	title = {Diagnosis of {Time}-{Sensitive} {Failures} in {Timed} {Discrete}-{Event} {Systems} with {Metric} {Interval} {Temporal} {Logics}},
	copyright = {https://doi.org/10.15223/policy-029},
	isbn = {979-8-3503-0124-3},
	url = {https://ieeexplore.ieee.org/document/10383314/},
	doi = {10.1109/CDC49753.2023.10383314},
	abstract = {In this paper, we address the problem of failure diagnosis in timed discrete-event systems modeled by timed automata. While existing works on this topic typically focus on failures modeled as particular events, many complex applications, especially time-critical systems, require the ability to identify time-sensitive failures associated with real-time information rather than just the occurrence of events at any time. To address this challenge, we propose the use of metric interval temporal logic (MITL) with continuous semantics on Boolean signals to formally describe time-sensitive failures. We introduce a novel concept called time-sensitive diagnosability (TS-diagnosability) to characterize whether or not any violation of the MITL task (i.e., failure) can be determined within a finite time elapsing. Furthermore, we provide a necessary and sufficient condition for verifying TS-diagnosability. Our results offer a more general framework for failure diagnosis of timed discrete-event systems.},
	language = {en},
	urldate = {2025-01-07},
	booktitle = {2023 62nd {IEEE} {Conference} on {Decision} and {Control} ({CDC})},
	publisher = {IEEE},
	author = {Dong, Weijie and Li, Shaoyuan and Yin, Xiang},
	month = dec,
	year = {2023},
	pages = {6827--6833},
	file = {PDF:/home/georgefkd/Zotero/storage/VCLQIRKH/Dong et al. - 2023 - Diagnosis of Time-Sensitive Failures in Timed Discrete-Event Systems with Metric Interval Temporal L.pdf:application/pdf},
}

@article{dhananjayan_metric_2014,
	title = {A metric temporal logic specification interface for real-time discrete-event control},
	volume = {44},
	url = {https://ieeexplore.ieee.org/abstract/document/6763114/},
	number = {9},
	urldate = {2025-01-07},
	journal = {IEEE Transactions on Systems, Man, and Cybernetics: Systems},
	author = {Dhananjayan, Amrith and Seow, Kiam Tian},
	year = {2014},
	note = {Publisher: IEEE},
	pages = {1204--1215},
	file = {Available Version (via Google Scholar):/home/georgefkd/Zotero/storage/7H75FIPN/Dhananjayan and Seow - 2014 - A metric temporal logic specification interface for real-time discrete-event control.pdf:application/pdf},
}

@article{gundana_event-based_2022,
	title = {Event-based signal temporal logic tasks: {Execution} and feedback in complex environments},
	volume = {7},
	shorttitle = {Event-based signal temporal logic tasks},
	url = {https://ieeexplore.ieee.org/abstract/document/9834056/},
	number = {4},
	urldate = {2025-01-07},
	journal = {IEEE Robotics and Automation Letters},
	author = {Gundana, David and Kress-Gazit, Hadas},
	year = {2022},
	note = {Publisher: IEEE},
	pages = {10001--10008},
	file = {Available Version (via Google Scholar):/home/georgefkd/Zotero/storage/8C95I952/Gundana and Kress-Gazit - 2022 - Event-based signal temporal logic tasks Execution and feedback in complex environments.pdf:application/pdf},
}

@misc{noauthor_microservices_nodate,
	title = {Microservices {Pattern}: {Pattern}: {API} {Gateway} / {Backends} for {Frontends}},
	shorttitle = {Microservices {Pattern}},
	url = {http://microservices.io/patterns/apigateway.html},
	abstract = {An API gateway acts a single entry point into the application, routing and composing requests to services},
	urldate = {2025-01-11},
	journal = {microservices.io},
	file = {Snapshot:/home/georgefkd/Zotero/storage/HB7P9CVV/apigateway.html:text/html},
}

@misc{noauthor_keep_nodate,
	title = {Keep {Django} {Under} {Control}: {Creating} {Custom} {Metrics} with {Prometheus} {\textbar} {Monterail}},
	shorttitle = {Keep {Django} {Under} {Control}},
	url = {https://www.monterail.com/blog/prometheus-custom-metrics},
	abstract = {Creating customer metrics in Django doesn't need to be tricky - here's how to do it with Prometheus-based monitoring system.},
	language = {en},
	urldate = {2025-01-11},
	file = {Snapshot:/home/georgefkd/Zotero/storage/JUGIDGGL/prometheus-custom-metrics.html:text/html},
}

@incollection{platzer_pyramid_2025,
	address = {Cham},
	title = {A {Pyramid} {Of} ({Formal}) {Software} {Verification}},
	volume = {14934},
	isbn = {978-3-031-71176-3 978-3-031-71177-0},
	url = {https://link.springer.com/10.1007/978-3-031-71177-0_24},
	abstract = {Abstract
            Over the past few years there has been significant progress in the various fields of software verification resulting in many useful tools and successful deployments, both academic and commercial. However much of the work describing these tools and ideas is written by and for the research community. The scale, diversity and focus of the literature can act as a barrier, separating industrial users and the wider academic community from the tools that could make their work more efficient, more certain and more productive. This tutorial gives a simple classification of verification techniques in terms of a pyramid and uses it to describe the six main schools of verification technologies. We have found this approach valuable for building collaborations with industry as it allows us to explain the intrinsic strengths and weaknesses of techniques and pick the right tool for any given industrial application. The model also highlights some of the cultural differences and unspoken assumptions of different areas of verification and illuminates future directions.},
	language = {en},
	urldate = {2025-01-20},
	booktitle = {Formal {Methods}},
	publisher = {Springer Nature Switzerland},
	author = {Brain, Martin and Polgreen, Elizabeth},
	editor = {Platzer, Andre and Rozier, Kristin Yvonne and Pradella, Matteo and Rossi, Matteo},
	year = {2025},
	doi = {10.1007/978-3-031-71177-0_24},
	note = {Series Title: Lecture Notes in Computer Science},
	pages = {393--419},
	file = {Available Version (via Google Scholar):/home/georgefkd/Zotero/storage/ACCTM5CT/Brain and Polgreen - 2025 - A Pyramid Of (Formal) Software Verification.pdf:application/pdf},
}

@book{aldini_software_2024,
	address = {Cham},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Software {Engineering} and {Formal} {Methods}. {SEFM} 2023 {Collocated} {Workshops}: {CIFMA} 2023 and {OpenCERT} 2023, {Eindhoven}, {The} {Netherlands}, {November} 6–10, 2023, {Revised} {Selected} {Papers}},
	volume = {14568},
	copyright = {https://www.springernature.com/gp/researchers/text-and-data-mining},
	isbn = {978-3-031-66020-7 978-3-031-66021-4},
	shorttitle = {Software {Engineering} and {Formal} {Methods}. {SEFM} 2023 {Collocated} {Workshops}},
	url = {https://link.springer.com/10.1007/978-3-031-66021-4},
	language = {en},
	urldate = {2025-01-20},
	publisher = {Springer Nature Switzerland},
	editor = {Aldini, Alessandro},
	year = {2024},
	doi = {10.1007/978-3-031-66021-4},
}

@article{martens_approach_nodate,
	title = {An {Approach} at {Quantifying} the {Reliability} of {Software}-{Controlled} {Systems} using {Formal} {Methods}},
	url = {https://research.tue.nl/files/333612426/Martens_J.pdf},
	urldate = {2025-01-20},
	author = {Martens, JWGT},
	file = {Available Version (via Google Scholar):/home/georgefkd/Zotero/storage/ZMK2QMRL/Martens - An Approach at Quantifying the Reliability of Software-Controlled Systems using Formal Methods.pdf:application/pdf},
}

@article{konnov_tla_2019,
	title = {{TLA}+ model checking made symbolic},
	volume = {3},
	issn = {2475-1421},
	url = {https://dl.acm.org/doi/10.1145/3360549},
	doi = {10.1145/3360549},
	abstract = {TLA+ is a language for formal specification of all kinds of computer systems. System designers use this language to specify concurrent, distributed, and fault-tolerant protocols, which are traditionally presented in pseudo-code. TLA+ is extremely concise yet expressive: The language primitives include Booleans, integers, functions, tuples, records, sequences, and sets thereof, which can be also nested. This is probably why the only model checker for TLA+ (called TLC) relies on explicit enumeration of values and states.
            In this paper, we present APALACHE -- a first symbolic model checker for TLA+. Like TLC, it assumes that all specification parameters are fixed and all states are finite structures. Unlike TLC, APALACHE translates the underlying transition relation into quantifier-free SMT constraints, which allows us to exploit the power of SMT solvers. Designing this translation is the central challenge that we address in this paper. Our experiments show that APALACHE outperforms TLC on examples with large state spaces.},
	language = {en},
	number = {OOPSLA},
	urldate = {2025-02-01},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Konnov, Igor and Kukovec, Jure and Tran, Thanh-Hai},
	month = oct,
	year = {2019},
	pages = {1--30},
	file = {Available Version (via Google Scholar):/home/georgefkd/Zotero/storage/FFRARGVK/Konnov et al. - 2019 - TLA+ model checking made symbolic.pdf:application/pdf},
}

@phdthesis{wu_parallelizing_2017,
	type = {{PhD} {Thesis}},
	title = {Parallelizing model checking algorithms using multi-core and many-core architectures},
	url = {https://dr.ntu.edu.sg/handle/10356/72377},
	urldate = {2025-02-01},
	author = {Wu, Zhimin},
	year = {2017},
	file = {Available Version (via Google Scholar):/home/georgefkd/Zotero/storage/5RHJJ3C3/Wu - 2017 - Parallelizing model checking algorithms using multi-core and many-core architectures.pdf:application/pdf},
}

@phdthesis{tran_symbolic_2024,
	type = {{PhD} {Thesis}},
	title = {Symbolic {Verification} of {TLA}+ {Specifications} with {Applications} to {Distributed} {Algorithms}},
	url = {https://repositum.tuwien.at/handle/20.500.12708/193082},
	urldate = {2025-02-01},
	school = {Technische Universität Wien},
	author = {Tran, Thanh Hai},
	year = {2024},
	file = {Available Version (via Google Scholar):/home/georgefkd/Zotero/storage/HW3QKJBG/Tran - 2024 - Symbolic Verification of TLA+ Specifications with Applications to Distributed Algorithms.pdf:application/pdf},
}
